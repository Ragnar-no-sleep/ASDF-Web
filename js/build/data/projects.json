{
  "burn-engine": {
    "id": "burn-engine",
    "icon": "\uD83D\uDD25",
    "title": "Burn Engine",
    "status": "live",
    "category": "core",
    "overview": "The core protocol that powers the entire ASDF ecosystem. Burn Engine implements the Optimistic Burn mechanism, automatically burning tokens on every transaction to create sustainable deflation.",
    "features": [
      {
        "name": "Automatic burn on every transaction",
        "what": "Every time someone transfers, swaps, or interacts with ASDF tokens, a small percentage is automatically sent to a burn address, permanently removing it from circulation.",
        "how": "The smart contract hooks into the SPL Token transfer instruction using a Program Derived Address (PDA). Before completing any transfer, it calculates the burn amount and executes a CPI (Cross-Program Invocation) to the burn instruction.",
        "why": "This creates sustainable deflation without requiring user action. Unlike manual burns, this ensures consistent supply reduction with every transaction, increasing scarcity over time."
      },
      {
        "name": "Configurable burn percentage",
        "what": "The burn rate can be adjusted by governance, allowing the community to fine-tune deflation based on market conditions.",
        "how": "The burn percentage is stored on-chain in a configuration account. Admin functions protected by multi-sig can update this value.",
        "why": "Flexibility is crucial for long-term sustainability. High burn rates work in bull markets but may be reduced during low activity periods."
      },
      {
        "name": "Real-time burn tracking",
        "what": "Every burn event is logged and indexed, providing transparent, verifiable data on total supply reduction.",
        "how": "The contract emits events after each burn. Helius webhooks capture these events and push them to the Burn Tracker service.",
        "why": "Transparency builds trust. Users can verify that burns are happening as promised."
      },
      {
        "name": "On-chain transparency",
        "what": "All burn operations are recorded directly on the Solana blockchain, creating an immutable audit trail.",
        "how": "Each burn creates a transaction with the burn instruction. The transaction signature, amount, and timestamp are permanently stored on-chain.",
        "why": "Blockchain transparency eliminates the need for trust. Anyone can independently verify burns."
      }
    ],
    "tech": ["Solana", "Rust", "Anchor", "SPL Token"],
    "dependencies": "Helius RPC for reliable transaction processing. Jupiter for swap integrations.",
    "architecture": "The Burn Engine uses a Program Derived Address (PDA) to manage burn operations. Each transaction triggers a CPI call to the SPL Token burn instruction.",
    "miniTree": [
      { "icon": "\uD83D\uDD27", "name": "Core Burn Logic", "status": "completed", "what": "The fundamental algorithm that calculates and executes token burns.", "how": "Rust smart contract intercepts SPL Token transfers via CPI hooks.", "why": "Automatic, trustless deflation without user action.", "future": "Dynamic burn rates based on market conditions." },
      { "icon": "\uD83D\uDCCA", "name": "Transaction Parser", "status": "completed", "what": "Analyzes incoming transactions to identify burn-eligible operations.", "how": "Parses Solana instruction data to identify token transfers.", "why": "Accurate parsing ensures correct burn amounts.", "future": "Support for complex multi-instruction transactions." },
      { "icon": "\uD83D\uDD17", "name": "Helius Integration", "status": "completed", "what": "Connection to Helius RPC infrastructure.", "how": "Uses Helius Enhanced API for transaction simulation. Webhooks notify backend of burn events.", "why": "Helius provides enterprise-grade reliability.", "future": "Multi-provider fallback system." },
      { "icon": "\uD83D\uDCC8", "name": "Analytics Module", "status": "completed", "what": "Collects and aggregates burn statistics.", "how": "Time-series database stores every burn event.", "why": "Transparent analytics build community trust.", "future": "Predictive analytics using ML." },
      { "icon": "\uD83D\uDEE1\uFE0F", "name": "Security Audit", "status": "in-progress", "what": "Comprehensive third-party security review.", "how": "OtterSec conducting line-by-line code review.", "why": "Security is paramount for DeFi.", "future": "Continuous audit program. Bug bounty expansion." },
      { "icon": "\uD83C\uDF10", "name": "Cross-chain Bridge", "status": "planned", "what": "Enable burn mechanism across multiple blockchains.", "how": "Wormhole/LayerZero integration.", "why": "Multi-chain presence expands reach.", "future": "Native bridges to EVM chains." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Complete security audit with OtterSec" },
      { "phase": "Q2", "text": "Implement configurable burn rates per token" },
      { "phase": "Q3", "text": "Launch cross-chain burn synchronization" }
    ],
    "integrations": ["Helius RPC", "Jupiter", "Raydium", "Metaplex"],
    "github": "https://github.com/asdf-ecosystem/burn-engine",
    "demo": null
  },
  "burn-tracker": {
    "id": "burn-tracker",
    "icon": "\uD83D\uDCCA",
    "title": "Burn Tracker",
    "status": "live",
    "category": "analytics",
    "overview": "Real-time dashboard monitoring all burn transactions across the ecosystem. Aggregates data from on-chain events, calculates deflation metrics, and projects future supply.",
    "features": [
      { "name": "Live burn feed with transaction details", "what": "A real-time stream showing every burn as it happens.", "how": "WebSocket connection receives push notifications from Helius webhooks.", "why": "Immediate visibility creates engagement and trust." },
      { "name": "Historical charts and analytics", "what": "Interactive charts showing burn trends over time.", "how": "PostgreSQL stores all historical burn data. Chart.js renders visualizations.", "why": "Historical data reveals patterns." },
      { "name": "Supply projection calculator", "what": "A tool that projects future token supply based on burn rates.", "how": "Takes historical burn rate averages, applies assumptions, calculates supply reduction curves.", "why": "Helps users understand long-term impact." },
      { "name": "Discord/Telegram alerts", "what": "Automated notifications when significant burns occur.", "how": "Threshold-based alert system triggers webhooks to Discord and Telegram.", "why": "Keeps the community informed and engaged." }
    ],
    "tech": ["Node.js", "Express", "WebSockets", "PostgreSQL", "Chart.js"],
    "dependencies": "Relies on Burn Engine events. Uses Helius webhooks.",
    "architecture": "Backend subscribes to Helius webhooks. PostgreSQL stores historical data. WebSocket server pushes updates to clients.",
    "miniTree": [
      { "icon": "\uD83D\uDCE1", "name": "Webhook Listener", "status": "completed", "what": "Receives real-time burn event notifications.", "how": "Node.js server listens on secure endpoint.", "why": "Real-time tracking without polling.", "future": "Multi-chain webhook support." },
      { "icon": "\uD83D\uDCBE", "name": "Data Pipeline", "status": "completed", "what": "Transforms raw blockchain data into queryable records.", "how": "Message queue handles incoming events. Worker processes extract and insert into PostgreSQL.", "why": "Clean data enables powerful queries.", "future": "Real-time data validation." },
      { "icon": "\uD83D\uDCC8", "name": "Analytics Engine", "status": "completed", "what": "Calculates aggregated statistics and projections.", "how": "Scheduled jobs compute aggregates. Moving averages cached in Redis.", "why": "Analytics transforms numbers into insights.", "future": "ML-powered predictions." },
      { "icon": "\uD83C\uDF10", "name": "REST API", "status": "completed", "what": "Public endpoints for burn data.", "how": "Express.js API with rate limiting.", "why": "Opens the ecosystem to builders.", "future": "GraphQL endpoint." },
      { "icon": "\uD83D\uDCF1", "name": "Embeddable Widget", "status": "in-progress", "what": "Plug-and-play component for other websites.", "how": "Lightweight JavaScript bundle loads via CDN.", "why": "Expands visibility across the web.", "future": "Theme customization." },
      { "icon": "\uD83E\uDD16", "name": "Telegram Bot", "status": "planned", "what": "Telegram bot for burn notifications.", "how": "Node.js bot using telegraf library.", "why": "Meet users where they are.", "future": "Multi-language support." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Launch embeddable widget" },
      { "phase": "Q2", "text": "ML-based burn rate predictions" },
      { "phase": "Q3", "text": "Multi-token comparison dashboard" }
    ],
    "integrations": ["Burn Engine", "Helius", "Discord", "Telegram"],
    "github": "https://github.com/asdf-ecosystem/burn-tracker",
    "demo": "https://alonisthe.dev/burns"
  },
  "token-launcher": {
    "id": "token-launcher",
    "icon": "\uD83D\uDE80",
    "title": "Token Launcher",
    "status": "live",
    "category": "tools",
    "overview": "One-click Solana SPL token deployment platform. Handles metadata creation, automatic liquidity pool setup on Raydium, and initial distribution configuration.",
    "features": [
      { "name": "SPL Token creation wizard", "what": "Step-by-step interface guiding users through token creation.", "how": "React wizard collects parameters. Backend validates and constructs the create mint transaction.", "why": "Democratizes token creation." },
      { "name": "Metaplex metadata setup", "what": "Automatic creation of on-chain metadata.", "how": "Metaplex SDK creates the metadata account. Logo uploaded to Arweave.", "why": "Metadata is essential for wallet display." },
      { "name": "Auto Raydium pool creation", "what": "One-click liquidity pool setup.", "how": "Raydium SDK creates an AMM pool.", "why": "Liquidity is essential for trading." },
      { "name": "Initial distribution tools", "what": "Batch transfer functionality for airdrops.", "how": "CSV upload parses recipients. Backend constructs versioned transactions.", "why": "Fair distribution is crucial for credibility." }
    ],
    "tech": ["React", "Solana Web3.js", "Metaplex SDK", "Raydium SDK"],
    "dependencies": "Integrates with Burn Engine for burn-enabled tokens.",
    "architecture": "Frontend wizard collects parameters. Backend validates and deploys. Raydium pool creation follows.",
    "miniTree": [
      { "icon": "\uD83D\uDCDD", "name": "Token Creation", "status": "completed", "what": "Core wizard for creating SPL tokens.", "how": "Step-by-step form. Solana Web3.js creates the mint.", "why": "Abstracts technical complexity.", "future": "Token cloning feature." },
      { "icon": "\uD83D\uDDBC\uFE0F", "name": "Metaplex Integration", "status": "completed", "what": "Rich token metadata.", "how": "Metaplex SDK creates on-chain metadata. Images on Arweave.", "why": "Makes tokens recognizable.", "future": "Dynamic metadata updates." },
      { "icon": "\uD83D\uDCA7", "name": "Raydium Pools", "status": "completed", "what": "Automated liquidity pool creation.", "how": "Raydium SDK creates concentrated liquidity pool.", "why": "Tokens need liquidity to be tradeable.", "future": "Multi-DEX deployment." },
      { "icon": "\uD83D\uDCCA", "name": "Management Dashboard", "status": "in-progress", "what": "Post-launch control panel.", "how": "React dashboard fetches on-chain data.", "why": "Ongoing management is needed.", "future": "Holder analytics. Airdrop tools." },
      { "icon": "\uD83D\uDD10", "name": "Multi-sig Support", "status": "planned", "what": "Multiple signers for token authorities.", "how": "Squads Protocol integration.", "why": "Single points of failure are risky.", "future": "Governance-controlled authorities." },
      { "icon": "\uD83D\uDCCB", "name": "Token Templates", "status": "planned", "what": "Pre-configured token setups.", "how": "Templates define parameters, burn rates, schedules.", "why": "Best practices encoded in templates.", "future": "Community-submitted templates." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Pre-configured token templates" },
      { "phase": "Q2", "text": "Multi-signature authority support" },
      { "phase": "Q3", "text": "Public API for integrations" }
    ],
    "integrations": ["Burn Engine", "Metaplex", "Raydium", "Jupiter"],
    "github": "https://github.com/asdf-ecosystem/launcher",
    "demo": "https://alonisthe.dev/ignition"
  },
  "oracle": {
    "id": "oracle",
    "icon": "\uD83D\uDD2E",
    "title": "ASDF Oracle",
    "status": "building",
    "category": "infrastructure",
    "overview": "Proprietary oracle calculating the K-Metric, a composite health indicator for the ecosystem. Aggregates data from multiple sources.",
    "features": [
      { "name": "K-Metric calculation algorithm", "what": "Composite score measuring ecosystem health.", "how": "Python algorithm assigns weights to normalized metrics.", "why": "Single metrics can be misleading. K-Metric provides holistic view." },
      { "name": "Multi-source data aggregation", "what": "Collects data from Helius, Jupiter, Birdeye, GitHub.", "how": "Scheduled collectors run every 5 minutes.", "why": "No single source tells the whole story." },
      { "name": "Webhook alerts for thresholds", "what": "Automated alerts when metrics cross thresholds.", "how": "Alert rules trigger webhook notifications.", "why": "Proactive monitoring prevents surprises." }
    ],
    "tech": ["Node.js", "Python", "Redis", "InfluxDB", "Grafana"],
    "dependencies": "Pulls data from Helius, Jupiter, Birdeye, internal burn metrics.",
    "architecture": "Data collectors fetch from APIs. Python calculates K-Metric. InfluxDB stores time-series. Grafana visualizes.",
    "miniTree": [
      { "icon": "\uD83D\uDCCA", "name": "K-Metric Algorithm", "status": "completed", "what": "Proprietary ecosystem health formula.", "how": "Normalizes metrics, applies weights, computes score.", "why": "Holistic health score.", "future": "Community-adjustable weights." },
      { "icon": "\uD83D\uDD17", "name": "Multi-source Aggregator", "status": "completed", "what": "Data collection from multiple sources.", "how": "Scheduled jobs fetch every 5 minutes.", "why": "Diverse sources mean resilience.", "future": "Dune Analytics integration." },
      { "icon": "\uD83D\uDCE1", "name": "REST API", "status": "in-progress", "what": "Public endpoints for K-Metric data.", "how": "Express.js API with rate limiting.", "why": "Open data enables ecosystem growth.", "future": "WebSocket real-time updates." },
      { "icon": "\uD83D\uDD14", "name": "Alert System", "status": "in-progress", "what": "Threshold-based notifications.", "how": "AlertManager evaluates rules, dispatches to Discord/Telegram.", "why": "Early warning prevents surprises.", "future": "Custom user alerts." },
      { "icon": "\uD83D\uDCC8", "name": "Historical Data", "status": "planned", "what": "Long-term K-Metric trends.", "how": "InfluxDB with tiered retention.", "why": "Historical context reveals trends.", "future": "Public data exports." },
      { "icon": "\uD83E\uDDE0", "name": "ML Predictions", "status": "planned", "what": "Predict future K-Metric values.", "how": "LSTM networks trained on historical data.", "why": "Prediction enables proactive decisions.", "future": "Ensemble models." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Public API with rate limiting" },
      { "phase": "Q2", "text": "On-chain oracle program" },
      { "phase": "Q3", "text": "ML-based prediction models" }
    ],
    "integrations": ["Helius", "Jupiter", "Birdeye", "Burn Tracker"],
    "github": "https://github.com/asdf-ecosystem/oracle",
    "demo": null
  },
  "learn-platform": {
    "id": "learn-platform",
    "icon": "\uD83D\uDCDA",
    "title": "Learn Platform",
    "status": "live",
    "category": "education",
    "overview": "Gamified educational platform with 5 progressive levels. Users earn XP and badges by completing interactive tutorials.",
    "features": [
      { "name": "5 progressive learning levels", "what": "Structured curriculum from basics to advanced.", "how": "Levels unlock sequentially as users complete requirements.", "why": "Progressive learning prevents overwhelm." },
      { "name": "XP and badge system", "what": "Gamification elements that reward progress.", "how": "Actions earn XP. Badges awarded for milestones.", "why": "Gamification increases engagement." },
      { "name": "Interactive quizzes", "what": "Knowledge checks with multiple choice questions.", "how": "Quiz engine validates answers with immediate feedback.", "why": "Active recall strengthens learning." },
      { "name": "Progress persistence", "what": "Progress saved across sessions.", "how": "LocalStorage saves completed lessons, XP, badges.", "why": "Nobody wants to start over." }
    ],
    "tech": ["Vanilla JS", "CSS3", "LocalStorage", "Service Worker"],
    "dependencies": "Standalone platform.",
    "architecture": "Single-page application with vanilla JavaScript. LocalStorage persists progress.",
    "miniTree": [
      { "icon": "\uD83D\uDCD6", "name": "5 Learning Levels", "status": "completed", "what": "Progressive curriculum.", "how": "Content structured as levels.", "why": "Learning works best with structure.", "future": "Expert-level content." },
      { "icon": "\uD83C\uDFC5", "name": "Badge System", "status": "completed", "what": "Visual achievements.", "how": "Progress tracking awards badges at milestones.", "why": "Gamification increases engagement.", "future": "Rare achievement badges." },
      { "icon": "\u2705", "name": "Quiz Engine", "status": "completed", "what": "Interactive knowledge checks.", "how": "JSON-defined quizzes with random selection.", "why": "Testing reinforces learning.", "future": "Adaptive difficulty." },
      { "icon": "\uD83D\uDCBE", "name": "Progress Sync", "status": "completed", "what": "Persistent progress tracking.", "how": "LocalStorage saves data. Versioned for migrations.", "why": "Users should not lose progress.", "future": "Cloud sync with wallet." },
      { "icon": "\uD83C\uDF10", "name": "Multi-language", "status": "in-progress", "what": "Platform localization.", "how": "i18n framework with JSON translation files.", "why": "Crypto is global.", "future": "Community translations." },
      { "icon": "\uD83C\uDF96\uFE0F", "name": "NFT Badges", "status": "planned", "what": "On-chain NFT certificates.", "how": "Metaplex NFTs minted after verification.", "why": "On-chain credentials are verifiable.", "future": "Soulbound tokens." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Spanish and French translations" },
      { "phase": "Q2", "text": "Community-contributed lessons" },
      { "phase": "Q3", "text": "On-chain certificate NFTs" }
    ],
    "integrations": ["Community Hub", "Ambassador Program"],
    "github": "https://github.com/asdf-ecosystem/learn",
    "demo": "https://alonisthe.dev/learn.html"
  },
  "rpc-monitor": {
    "id": "rpc-monitor",
    "icon": "\uD83D\uDCE1",
    "title": "RPC Monitor",
    "status": "live",
    "category": "infrastructure",
    "overview": "Infrastructure health monitoring for all RPC endpoints. Tracks latency, uptime, and error rates.",
    "features": [
      { "name": "Multi-endpoint health checks", "what": "Continuous monitoring of all RPC endpoints.", "how": "Cron job pings each endpoint every 30 seconds.", "why": "RPC reliability is critical." },
      { "name": "Latency tracking", "what": "Measures response times for each endpoint.", "how": "Each health check records response time. Percentiles calculated.", "why": "Slow RPCs degrade user experience." },
      { "name": "Discord/Telegram alerts", "what": "Immediate notifications when endpoints go down.", "how": "AlertManager triggers webhooks.", "why": "Downtime costs money." }
    ],
    "tech": ["Node.js", "Prometheus", "Grafana", "Docker"],
    "dependencies": "Monitors Helius and backup RPC endpoints.",
    "architecture": "Cron-based health checker. Results stored in Prometheus. Grafana dashboards visualize.",
    "miniTree": [
      { "icon": "\uD83D\uDC93", "name": "Health Checker", "status": "completed", "what": "Core monitoring service.", "how": "Node.js cron sends getHealth requests every 30s.", "why": "First line of defense.", "future": "Custom health check types." },
      { "icon": "\uD83D\uDCCA", "name": "Prometheus Export", "status": "completed", "what": "Metrics in Prometheus format.", "how": "prom-client exposes /metrics endpoint.", "why": "Industry standard format.", "future": "Custom metric labels." },
      { "icon": "\uD83D\uDD14", "name": "Alert Manager", "status": "completed", "what": "Automated notifications.", "how": "Rules trigger Discord/Telegram alerts.", "why": "Human attention is limited.", "future": "Escalation policies." },
      { "icon": "\uD83D\uDCC8", "name": "Grafana Dashboards", "status": "in-progress", "what": "Visual health dashboards.", "how": "Pre-built Grafana dashboards query Prometheus.", "why": "Visualization makes data actionable.", "future": "Public status page." },
      { "icon": "\uD83E\uDD16", "name": "Auto-failover", "status": "planned", "what": "Automatic switching to backup RPCs.", "how": "Failover logic evaluates health scores.", "why": "Manual intervention is slow.", "future": "Weighted load balancing." },
      { "icon": "\uD83C\uDF0D", "name": "Multi-region", "status": "planned", "what": "Monitoring from multiple locations.", "how": "Distributed checkers in NA, EU, Asia.", "why": "RPC issues can be regional.", "future": "Latency-based routing." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Automated failover to backup RPCs" },
      { "phase": "Q2", "text": "Multi-region endpoint monitoring" },
      { "phase": "Q3", "text": "Cost tracking and optimization" }
    ],
    "integrations": ["Helius", "All Ecosystem Services"],
    "github": "https://github.com/asdf-ecosystem/rpc-monitor",
    "demo": null
  },
  "holdex": {
    "id": "holdex",
    "icon": "\uD83D\uDCC9",
    "title": "HolDEX Terminal",
    "status": "live",
    "category": "trading",
    "overview": "Professional trading interface with TradingView charts, real-time order books, and technical analysis tools.",
    "features": [
      { "name": "TradingView charting", "what": "Professional-grade charts with 100+ indicators.", "how": "TradingView widget integration.", "why": "Traders need professional tools." },
      { "name": "Real-time order books", "what": "Live aggregated order book.", "how": "WebSocket connections aggregate data.", "why": "Order book depth reveals market sentiment." },
      { "name": "Watchlists and alerts", "what": "Custom token watchlists with price alerts.", "how": "User-created lists stored in PostgreSQL.", "why": "No one can watch every token." }
    ],
    "tech": ["React", "TradingView", "Jupiter SDK", "PostgreSQL"],
    "dependencies": "Uses ASDF Oracle for K-Metric. Jupiter for trade execution.",
    "architecture": "React frontend with TradingView widget. WebSocket feeds. Jupiter SDK handles swaps.",
    "miniTree": [
      { "icon": "\uD83D\uDCC8", "name": "TradingView Charts", "status": "completed", "what": "Professional charting.", "how": "TradingView widget with custom theme.", "why": "Industry standard interface.", "future": "Custom indicators." },
      { "icon": "\uD83D\uDCCB", "name": "Watchlists", "status": "completed", "what": "Custom token lists.", "how": "User-defined lists in PostgreSQL.", "why": "Focus attention on tokens that matter.", "future": "Shared watchlists." },
      { "icon": "\uD83D\uDD14", "name": "Price Alerts", "status": "in-progress", "what": "Price target notifications.", "how": "Background job monitors prices.", "why": "Cannot stare at screens 24/7.", "future": "Complex conditions." },
      { "icon": "\uD83D\uDC0B", "name": "Whale Tracking", "status": "in-progress", "what": "Monitor large wallet movements.", "how": "Helius webhooks track large transfers.", "why": "Whales often move before price action.", "future": "Flow analysis." },
      { "icon": "\uD83E\uDD16", "name": "Trading Bots", "status": "planned", "what": "Automated trading strategies.", "how": "User configures strategy. Bot executes via Jupiter.", "why": "Automation removes emotion.", "future": "Strategy marketplace." },
      { "icon": "\uD83D\uDCCA", "name": "Portfolio View", "status": "planned", "what": "Portfolio tracking.", "how": "Wallet connection reads balances.", "why": "Know your performance.", "future": "Tax reporting." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Copy trading functionality" },
      { "phase": "Q2", "text": "Automated trading strategies" },
      { "phase": "Q3", "text": "DEX aggregation beyond Jupiter" }
    ],
    "integrations": ["ASDF Oracle", "Jupiter", "Birdeye"],
    "github": "https://github.com/asdf-ecosystem/holdex",
    "demo": null
  },
  "games-platform": {
    "id": "games-platform",
    "icon": "\uD83C\uDFAE",
    "title": "Games Platform",
    "status": "live",
    "category": "gaming",
    "overview": "Suite of browser-based mini-games with Solana wallet integration. Features weekly leaderboards and ticket rewards.",
    "features": [
      { "name": "9 unique mini-games", "what": "Collection of casual games.", "how": "Canvas API renders 2D games. Modular architecture.", "why": "Variety keeps users engaged." },
      { "name": "Leaderboard system", "what": "Global and weekly rankings.", "how": "Redis sorted sets. Anti-cheat validated scores.", "why": "Competition drives engagement." },
      { "name": "Ticket-based rewards", "what": "Tickets earned based on performance.", "how": "Score-to-ticket conversion server-side.", "why": "Tangible rewards increase engagement." }
    ],
    "tech": ["Vanilla JS", "Canvas API", "Solana Web3.js", "Express"],
    "dependencies": "Uses ASDF Oracle for reward calculations.",
    "architecture": "Microservices with separate game engine and rewards service.",
    "miniTree": [
      { "icon": "\uD83C\uDFB2", "name": "9 Mini-games", "status": "completed", "what": "Collection of casual games.", "how": "Canvas API. Modular architecture.", "why": "Variety keeps users engaged.", "future": "Community game submissions." },
      { "icon": "\uD83C\uDFC6", "name": "Leaderboards", "status": "completed", "what": "Weekly competitive rankings.", "how": "Redis sorted sets with weekly resets.", "why": "Competition drives engagement.", "future": "All-time leaderboards." },
      { "icon": "\uD83C\uDF9F\uFE0F", "name": "Ticket System", "status": "completed", "what": "Entry tickets for prize pools.", "how": "Tickets tracked per session.", "why": "Creates skin in the game.", "future": "Ticket marketplace." },
      { "icon": "\uD83C\uDF81", "name": "Auto Rewards", "status": "in-progress", "what": "Automated prize distribution.", "how": "Smart contract holds pool. Weekly cron triggers distribution.", "why": "Manual distribution is slow.", "future": "Instant micro-rewards." },
      { "icon": "\uD83D\uDEE1\uFE0F", "name": "Anti-cheat v2", "status": "in-progress", "what": "Enhanced cheat detection.", "how": "Server-side validation. Pattern analysis.", "why": "Cheaters ruin fair competition.", "future": "Real-time detection." },
      { "icon": "\uD83C\uDFC5", "name": "Tournaments", "status": "planned", "what": "Organized PvP competitions.", "how": "Bracket system. Live spectating.", "why": "Tournaments create events.", "future": "Team tournaments." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "PvP tournament mode" },
      { "phase": "Q2", "text": "NFT reward integration" },
      { "phase": "Q3", "text": "Mobile companion app" }
    ],
    "integrations": ["ASDF Oracle", "Burn Engine", "Wallet Adapters"],
    "github": "https://github.com/asdf-ecosystem/games",
    "demo": "https://alonisthe.dev/games.html"
  },
  "forecast": {
    "id": "forecast",
    "icon": "\uD83D\uDCC8",
    "title": "ASDForecast",
    "status": "live",
    "category": "trading",
    "overview": "Prediction market platform for forecasting prices and events. Place predictions and earn rewards for accuracy.",
    "features": [
      { "name": "Price predictions", "what": "Forecast token prices at specific dates.", "how": "Smart contract locks stakes. Oracle fetches actual price for resolution.", "why": "Gamifies market analysis." },
      { "name": "Event markets", "what": "Predict ecosystem events.", "how": "Binary outcome markets with Yes/No shares.", "why": "Extends prediction beyond price." },
      { "name": "Leaderboards", "what": "Track top forecasters.", "how": "Historical predictions tracked. Accuracy calculated.", "why": "Recognition motivates participation." }
    ],
    "tech": ["Solana", "Rust", "Anchor", "React"],
    "dependencies": "Uses ASDF Oracle for price resolution.",
    "architecture": "Prediction markets on Solana smart contracts. Oracle integration for resolution.",
    "miniTree": [
      { "icon": "\uD83C\uDFAF", "name": "Price Markets", "status": "completed", "what": "Markets for price predictions.", "how": "Smart contract manages stakes and payouts.", "why": "Core prediction functionality.", "future": "Range predictions." },
      { "icon": "\uD83D\uDCCA", "name": "Event Markets", "status": "completed", "what": "Binary markets for events.", "how": "Yes/No share trading.", "why": "Captures predictions beyond price.", "future": "Multi-outcome events." },
      { "icon": "\uD83C\uDFC6", "name": "Leaderboards", "status": "completed", "what": "Rankings of top forecasters.", "how": "Accuracy calculations and profit aggregation.", "why": "Gamification and recognition.", "future": "Seasonal competitions." },
      { "icon": "\uD83D\uDD2E", "name": "Oracle Integration", "status": "in-progress", "what": "Reliable price feeds.", "how": "ASDF Oracle integration with fallbacks.", "why": "Accurate resolution is critical.", "future": "Multi-oracle consensus." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Launch additional event markets" },
      { "phase": "Q2", "text": "Seasonal prediction tournaments" },
      { "phase": "Q3", "text": "Advanced analytics dashboard" }
    ],
    "integrations": ["ASDF Oracle", "Helius", "Jupiter"],
    "github": "https://github.com/sollama58/ASDForecast",
    "demo": null
  },
  "ignition": {
    "id": "ignition",
    "icon": "\uD83D\uDD25",
    "title": "Ignition",
    "status": "live",
    "category": "launchpad",
    "overview": "Token launch platform and incubator. Provides fair launch mechanisms and vesting schedules.",
    "features": [
      { "name": "Fair launch mechanism", "what": "Equal opportunity token distribution.", "how": "Time-weighted contributions. Max caps. Anti-bot measures.", "why": "Fair launches build trust." },
      { "name": "Vesting schedules", "what": "Configurable token unlock schedules.", "how": "Smart contract holds tokens with time-locked release.", "why": "Prevents immediate dumps." },
      { "name": "Project incubation", "what": "Support for new projects.", "how": "Application and review process. Technical guidance.", "why": "Quality control for ecosystem." }
    ],
    "tech": ["Solana", "Rust", "Anchor", "React"],
    "dependencies": "Burn Engine integration for launch burns.",
    "architecture": "Launch contracts manage contributions and distribution. Vesting contracts handle unlocks.",
    "miniTree": [
      { "icon": "\uD83D\uDE80", "name": "Launch Platform", "status": "completed", "what": "Core fair launch platform.", "how": "Smart contracts manage contributions and distribution.", "why": "Foundation of fair launches.", "future": "Dutch auctions." },
      { "icon": "\uD83D\uDD12", "name": "Vesting Contracts", "status": "completed", "what": "Time-locked distribution.", "how": "PDAs hold vested tokens. Claim function checks schedule.", "why": "Prevents immediate selling.", "future": "Milestone-based vesting." },
      { "icon": "\uD83C\uDF31", "name": "Incubator", "status": "in-progress", "what": "Project review and support.", "how": "Application portal, team review, audit.", "why": "Quality control.", "future": "Mentor network." },
      { "icon": "\uD83D\uDCCB", "name": "Whitelist System", "status": "completed", "what": "Community allocation management.", "how": "Engagement-based scoring. Reserved tiers.", "why": "Rewards active community.", "future": "Dynamic whitelisting." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Launch first incubated projects" },
      { "phase": "Q2", "text": "Introduce staking for allocation boost" },
      { "phase": "Q3", "text": "Cross-ecosystem launch partnerships" }
    ],
    "integrations": ["Burn Engine", "ASDF Oracle", "Helius"],
    "github": "https://github.com/zeyxx",
    "demo": null
  },
  "community-hub": {
    "id": "community-hub",
    "icon": "\uD83C\uDFE0",
    "title": "Community Hub",
    "status": "building",
    "category": "community",
    "overview": "Centralized platform for community resources, events, and governance tools.",
    "features": [
      { "name": "Event calendar", "what": "Shared calendar for community events.", "how": "Next.js with PostgreSQL. Discord bot syncs bidirectionally.", "why": "Centralized scheduling." },
      { "name": "Proposal system", "what": "Platform for improvement proposals.", "how": "Structured form. Discussion threads. Token-weighted voting.", "why": "Community input shapes the project." },
      { "name": "Discord integration", "what": "Two-way sync with Discord.", "how": "Discord.js bot monitors channels.", "why": "Meet users where they are." }
    ],
    "tech": ["Next.js", "Prisma", "PostgreSQL", "Discord.js"],
    "dependencies": "Syncs with Discord server.",
    "architecture": "Next.js app with SSR. Prisma ORM. Discord bot for sync.",
    "miniTree": [
      { "icon": "\uD83D\uDCC5", "name": "Event Calendar", "status": "completed", "what": "Shared event calendar.", "how": "Next.js component with PostgreSQL.", "why": "Centralized scheduling.", "future": "Calendar exports." },
      { "icon": "\uD83D\uDCE2", "name": "Announcements", "status": "completed", "what": "Official announcement feed.", "how": "Discord bot captures messages.", "why": "Discord messages get buried.", "future": "Newsletter subscriptions." },
      { "icon": "\uD83D\uDDF3\uFE0F", "name": "Proposal System", "status": "in-progress", "what": "Community proposals.", "how": "Structured form. Discussion threads.", "why": "Community input matters.", "future": "Proposal templates." },
      { "icon": "\uD83D\uDCCA", "name": "Community Metrics", "status": "planned", "what": "Health dashboard.", "how": "Aggregates Discord, Hub, on-chain data.", "why": "Data-driven management.", "future": "Churn analysis." },
      { "icon": "\uD83C\uDFDB\uFE0F", "name": "DAO Voting", "status": "planned", "what": "On-chain governance.", "how": "Realms or custom SPL governance.", "why": "True decentralization.", "future": "Quadratic voting." },
      { "icon": "\uD83D\uDCB0", "name": "Treasury View", "status": "planned", "what": "Treasury dashboard.", "how": "On-chain data for treasury wallets.", "why": "Transparency builds trust.", "future": "Budget proposals." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "On-chain proposal voting" },
      { "phase": "Q2", "text": "Delegation system" },
      { "phase": "Q3", "text": "Treasury management dashboard" }
    ],
    "integrations": ["Discord", "Ambassador Program", "Learn Platform"],
    "github": "https://github.com/asdf-ecosystem/hub",
    "demo": null
  },
  "deploy-pipeline": {
    "id": "deploy-pipeline",
    "icon": "\uD83D\uDD27",
    "title": "Deploy Pipeline",
    "status": "building",
    "category": "infrastructure",
    "overview": "CI/CD automation for all ecosystem services. Testing, staging, and production deployments.",
    "features": [
      { "name": "GitHub Actions workflows", "what": "Automated pipelines.", "how": "YAML workflow files. Matrix builds.", "why": "Manual deployment is error-prone." },
      { "name": "Docker containerization", "what": "Services as Docker containers.", "how": "Multi-stage Dockerfiles.", "why": "Consistent environments." },
      { "name": "Blue-green deployments", "what": "Zero-downtime deployments.", "how": "New version deployed to green. Traffic switched atomically.", "why": "Zero downtime expected." }
    ],
    "tech": ["GitHub Actions", "Docker", "Kubernetes", "Terraform"],
    "dependencies": "Deploys all ecosystem services.",
    "architecture": "GitHub Actions trigger on PR merge. Docker builds. Kubernetes orchestration.",
    "miniTree": [
      { "icon": "\uD83D\uDD04", "name": "GitHub Actions", "status": "completed", "what": "Automated CI/CD workflows.", "how": "YAML workflows. Matrix builds.", "why": "Automation ensures consistency.", "future": "Self-hosted runners." },
      { "icon": "\uD83D\uDC33", "name": "Docker Builds", "status": "completed", "what": "Containerized services.", "how": "Multi-stage Dockerfiles.", "why": "Eliminates environment issues.", "future": "Build cache optimization." },
      { "icon": "\u2638\uFE0F", "name": "K8s Deployment", "status": "in-progress", "what": "Kubernetes orchestration.", "how": "Manifests and Helm charts.", "why": "Self-healing and scaling.", "future": "Horizontal autoscaling." },
      { "icon": "\uD83D\uDD35", "name": "Blue-green Deploy", "status": "in-progress", "what": "Zero-downtime deployments.", "how": "Two identical environments.", "why": "Zero downtime during updates.", "future": "A/B testing." },
      { "icon": "\uD83D\uDCCA", "name": "Post-deploy Monitor", "status": "planned", "what": "Health verification after deploy.", "how": "Post-deploy hooks run integration tests.", "why": "Deployment verified healthy.", "future": "Performance baseline comparison." },
      { "icon": "\uD83E\uDD9C", "name": "Canary Releases", "status": "planned", "what": "Gradual rollout.", "how": "Traffic split between versions.", "why": "Limit blast radius.", "future": "Feature flag integration." }
    ],
    "roadmap": [
      { "phase": "Q1", "text": "Canary deployment support" },
      { "phase": "Q2", "text": "Automated rollback triggers" },
      { "phase": "Q3", "text": "Cost tracking and optimization" }
    ],
    "integrations": ["RPC Monitor", "All Services"],
    "github": "https://github.com/asdf-ecosystem/pipeline",
    "demo": null
  },
  "ambassador-program": {
    "id": "ambassador-program",
    "icon": "\uD83C\uDF96\uFE0F",
    "title": "Ambassador Program",
    "status": "planned",
    "category": "community",
    "overview": "Tiered contributor program with missions, ranks, and NFT badges.",
    "features": [
      { "name": "Mission system", "what": "Structured tasks for points.", "how": "Missions with auto or manual verification.", "why": "Clear goals guide contribution." },
      { "name": "Rank progression", "what": "Bronze to Diamond tiers.", "how": "Points accumulate. Thresholds trigger upgrades.", "why": "Gamification drives engagement." },
      { "name": "NFT badges", "what": "On-chain achievement badges.", "how": "Metaplex soulbound NFTs.", "why": "Permanent, verifiable proof." }
    ],
    "tech": ["Next.js", "Metaplex", "PostgreSQL", "Discord.js"],
    "dependencies": "Integrates with Community Hub.",
    "architecture": "Mission tracking via Discord bot. NFT badges on-chain. Reward distribution automated.",
    "miniTree": [
      { "icon": "\uD83D\uDCCB", "name": "Mission System", "status": "planned", "what": "Structured contribution tasks.", "how": "Missions with verification.", "why": "Clear goals guide contribution.", "future": "Community-submitted missions." },
      { "icon": "\uD83C\uDFC6", "name": "Rank Progression", "status": "planned", "what": "Tiered ambassador levels.", "how": "Points accumulate toward ranks.", "why": "Gamification drives engagement.", "future": "Leadership councils." },
      { "icon": "\uD83D\uDCCA", "name": "Contribution Tracking", "status": "planned", "what": "Automated activity logging.", "how": "Discord, Twitter, GitHub integrations.", "why": "Fair rewards require accurate tracking.", "future": "More platforms." },
      { "icon": "\uD83C\uDF96\uFE0F", "name": "NFT Badges", "status": "planned", "what": "On-chain achievements.", "how": "Metaplex soulbound NFTs.", "why": "Permanent proof of contribution.", "future": "Dynamic badges." },
      { "icon": "\uD83D\uDCB0", "name": "Auto Rewards", "status": "planned", "what": "Periodic token distribution.", "how": "Smart contract holds pool. Pro-rata distribution.", "why": "Timely rewards maintain motivation.", "future": "Streak bonuses." },
      { "icon": "\uD83C\uDF0D", "name": "Regional Leads", "status": "planned", "what": "Geographic leadership.", "how": "Top ambassadors nominated for regional roles.", "why": "Local presence builds community.", "future": "Regional event budgets." }
    ],
    "roadmap": [
      { "phase": "Q2", "text": "Launch beta with core missions" },
      { "phase": "Q3", "text": "NFT badge minting" },
      { "phase": "Q4", "text": "Regional ambassador structure" }
    ],
    "integrations": ["Community Hub", "Metaplex", "Discord"],
    "github": null,
    "demo": null
  },
  "content-factory": {
    "id": "content-factory",
    "icon": "\uD83C\uDFAC",
    "title": "Content Factory",
    "status": "planned",
    "category": "community",
    "overview": "Tools and templates for community content creators.",
    "features": [
      { "name": "Template library", "what": "Pre-designed graphics templates.", "how": "Cloudinary with editable layers.", "why": "Templates lower the barrier." },
      { "name": "Meme generator", "what": "Easy meme creation tool.", "how": "Canvas-based editor.", "why": "Memes drive viral spread." },
      { "name": "Creator rewards", "what": "Performance-based rewards.", "how": "Engagement metrics tracked.", "why": "Incentives drive output." }
    ],
    "tech": ["React", "Canvas API", "Cloudinary", "PostgreSQL"],
    "dependencies": "Integrates with Ambassador Program.",
    "architecture": "React app with canvas editor. Templates in Cloudinary. Engagement tracked for rewards.",
    "miniTree": [
      { "icon": "\uD83D\uDDBC\uFE0F", "name": "Template Library", "status": "planned", "what": "Pre-designed templates.", "how": "Cloudinary with editable layers.", "why": "Not everyone is a designer.", "future": "Community submissions." },
      { "icon": "\uD83C\uDFA8", "name": "Meme Generator", "status": "planned", "what": "Easy meme creation.", "how": "Canvas-based editor.", "why": "Memes drive viral spread.", "future": "AI suggestions." },
      { "icon": "\uD83D\uDCC5", "name": "Post Scheduler", "status": "planned", "what": "Schedule social posts.", "how": "Calendar interface. Queue system.", "why": "Consistent posting.", "future": "Optimal time suggestions." },
      { "icon": "\uD83D\uDCB0", "name": "Creator Rewards", "status": "planned", "what": "Performance-based rewards.", "how": "Engagement metrics tracked.", "why": "Incentives drive output.", "future": "Tiered creator program." },
      { "icon": "\uD83D\uDCCA", "name": "Analytics", "status": "planned", "what": "Content performance tracking.", "how": "APIs pull engagement data.", "why": "Data improves content.", "future": "Competitor analysis." },
      { "icon": "\uD83E\uDD16", "name": "AI Suggestions", "status": "planned", "what": "AI content ideas.", "how": "LLM integration for suggestions.", "why": "Creative blocks slow production.", "future": "Brand voice training." }
    ],
    "roadmap": [
      { "phase": "Q2", "text": "Launch template library" },
      { "phase": "Q3", "text": "Meme generator with AI" },
      { "phase": "Q4", "text": "Creator rewards program" }
    ],
    "integrations": ["Ambassador Program", "Discord", "Twitter"],
    "github": null,
    "demo": null
  },
  "security-audit": {
    "id": "security-audit",
    "icon": "\uD83D\uDEE1\uFE0F",
    "title": "Security Audit",
    "status": "planned",
    "category": "infrastructure",
    "overview": "Security scanning suite for smart contracts and APIs.",
    "features": [
      { "name": "Smart contract scanning", "what": "Automated vulnerability analysis.", "how": "Slither and custom analyzers.", "why": "Smart contract bugs can be catastrophic." },
      { "name": "API fuzzing", "what": "Automated API testing.", "how": "OWASP ZAP generates test cases.", "why": "APIs are attack surfaces." },
      { "name": "Continuous monitoring", "what": "Ongoing security scanning.", "how": "GitHub Actions integration.", "why": "Security is not one-time." }
    ],
    "tech": ["Python", "Slither", "Mythril", "OWASP ZAP"],
    "dependencies": "Scans all ecosystem smart contracts.",
    "architecture": "Python orchestration. Slither/Mythril for contracts. OWASP ZAP for APIs.",
    "miniTree": [
      { "icon": "\uD83D\uDD0D", "name": "Contract Scanner", "status": "planned", "what": "Automated contract analysis.", "how": "Slither-style analyzers.", "why": "Catches common issues.", "future": "Custom rule definitions." },
      { "icon": "\uD83D\uDD77\uFE0F", "name": "API Fuzzing", "status": "planned", "what": "Automated API testing.", "how": "OWASP ZAP fuzzer.", "why": "Discovers input validation issues.", "future": "Stateful fuzzing." },
      { "icon": "\uD83D\uDCCB", "name": "Checklist System", "status": "planned", "what": "Manual review checklist.", "how": "Structured checklist per project type.", "why": "Not everything is automatable.", "future": "Role-based checklists." },
      { "icon": "\uD83D\uDCDD", "name": "Auto Reports", "status": "planned", "what": "Automated security reports.", "how": "Aggregates findings. PDF export.", "why": "Consistent reporting.", "future": "Trend analysis." },
      { "icon": "\uD83D\uDD14", "name": "Vuln Alerts", "status": "planned", "what": "Real-time vulnerability alerts.", "how": "Continuous scanning with alerts.", "why": "Speed matters in security.", "future": "CVE monitoring." },
      { "icon": "\uD83C\uDFC6", "name": "Bug Bounty", "status": "planned", "what": "External researcher incentives.", "how": "Submission portal. Triage process.", "why": "External eyes find blind spots.", "future": "Immunefi partnership." }
    ],
    "roadmap": [
      { "phase": "Q2", "text": "Basic contract scanning" },
      { "phase": "Q3", "text": "API security integration" },
      { "phase": "Q4", "text": "Bug bounty platform" }
    ],
    "integrations": ["Deploy Pipeline", "All Smart Contracts"],
    "github": null,
    "demo": null
  }
}
